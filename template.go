// Copyright 2013 Jonas mg
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.

package main

import (
	"fmt"
	"strconv"
	"strings"
)

const TMPL_SERVER_GO = `// MACHINE GENERATED BY easycert (github.com/kless/easycert)
// From {{.System}} ({{.Arch}}) with "{{.Version}}", on {{.Date}}
// Valid for: {{.ValidUntil}}

package main

import (
	"crypto/tls"
	//"crypto/x509"
	"log"
)

var ServerTLSConfig *tls.Config

func init() {
	CA_CERT_BLOCK := {{.CACert}}

	CA_KEY_BLOCK := {{.CAKey}}

	cert, err := tls.X509KeyPair(CA_CERT_BLOCK, CA_KEY_BLOCK)
	if err != nil {
		log.Fatal("server: load keys: ", err)
	}

	/*certPool := x509.NewCertPool()
	if ok := certPool.AppendCertsFromPEM(CA_CERT_BLOCK); !ok {
		log.Fatal("server: CA certificate not valid")
	}*/

	ServerTLSConfig = &tls.Config{
		Certificates: []tls.Certificate{cert},
		//ClientCAs:    certPool,
	}
}
`

const TMPL_CLIENT_GO = `// MACHINE GENERATED BY easycert (github.com/kless/easycert)
// From {{.System}} ({{.Arch}}) with "{{.Version}}", on {{.Date}}
// Server valid for: {{.ValidUntil}}

// MUST set the filenames for both certificate and key
// var CertFile, KeyFile string

package main

import (
	"crypto/tls"
	"crypto/x509"
	"log"
)

var ClientTLSConfig *tls.Config

func init() {
	CA_CERT_BLOCK := {{.CACert}}

	cert, err := tls.LoadX509KeyPair(CertFile, KeyFile)
	if err != nil {
		log.Fatal("client: load keys: ", err)
	}

	certPool := x509.NewCertPool()
	if ok := certPool.AppendCertsFromPEM(CA_CERT_BLOCK); !ok {
		log.Fatal("client: CA certificate not valid")
	}

	ClientTLSConfig = &tls.Config{
		Certificates: []tls.Certificate{cert},
		RootCAs:      certPool,
	}
}
`

// GoBlock represents the definition of a "[]byte" in Go.
type GoBlock []byte

func (b GoBlock) String() string {
	s := make([]string, len(b))

	for i, v := range b {
		if i != 0 && i%18 == 0 {
			s[i-1] = s[i-1][:len(s[i-1])-1] // remove anterior space
			s[i] = "\n\t\t"
		}
		s[i] += fmt.Sprintf("%s, ", strconv.Itoa(int(v)))
	}

	i := len(s) - 1
	s[i] = s[i][:len(s[i])-1] // remove last space

	return fmt.Sprintf("[]byte{\n\t\t%s\n\t}", strings.Join(s, ""))
}
