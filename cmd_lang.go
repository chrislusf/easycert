// Copyright 2013 Jonas mg
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.

package main

import (
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"strconv"
	"strings"
	"text/template"
	"time"
)

var cmdLang = &Command{
	Run:       runLang,
	UsageLine: "lang [-go] -ca-cert file [-server-cert name] [-client]",
	Short:     "generate files into a language to handle the certificate",
	Long: `
"lang" generate files into a language to handle the certificate.
To look for the file, it uses the certificates directory when the "file" is just
a name or the path when the "file" is an absolute or relatative path.
`,
}

var (
	CACert     = flag.String("ca-cert", NAME_CA, "name or file of CA's certificate")
	ServerCert = flag.String("server-cert", "", "name of server's certificate")

	IsClient = flag.Bool("client", false, "create file for the client")
	IsGo     = flag.Bool("go", true, "create files for Go language")
)

func init() {
	client := flag.Lookup("client")
	clientVal, _ := strconv.ParseBool(client.Value.String())
	cmdLang.Flag.BoolVar(IsClient, client.Name, clientVal, client.Usage)

	go_ := flag.Lookup("go")
	goVal, _ := strconv.ParseBool(go_.Value.String())
	cmdLang.Flag.BoolVar(IsGo, go_.Name, goVal, go_.Usage)
}

func runLang(cmd *Command, args []string) {
	if *CACert == "" {
		log.Fatal("Missing required parameter in flag `-ca-cert`")
	}
	if (*CACert)[0] != '.' && (*CACert)[0] != os.PathSeparator {
		*CACert = filepath.Join(Dir.Cert, *CACert+EXT_CERT)
	}

	serverFile := ""
	clientFile := ""
	if *IsGo {
		serverFile = FILE_SERVER_GO
		clientFile = FILE_CLIENT_GO
	} else {
		log.Print("Missing required parameter -- `-go`")
		cmd.Usage()
	}

	if *ServerCert != "" {
		if _, err := os.Stat(serverFile); !os.IsNotExist(err) {
			log.Fatalf("File already exists: %q", serverFile)
		}
	}
	if *IsClient {
		if _, err := os.Stat(clientFile); !os.IsNotExist(err) {
			log.Fatalf("File already exists: %q", clientFile)
		}
	}

	Cert2Lang(
		filepath.Join(Dir.Cert, *ServerCert+EXT_CERT),
		filepath.Join(Dir.Key, *ServerCert+EXT_KEY),
	)
}

// Cert2Lang creates files in Go language to handle the certificate.
func Cert2Lang(certFile, keyFile string) {
	caCertBlock, err := ioutil.ReadFile(*CACert)
	if err != nil {
		log.Fatal(err)
	}
	certBlock, err := ioutil.ReadFile(certFile)
	if err != nil {
		log.Fatal(err)
	}
	keyBlock, err := ioutil.ReadFile(keyFile)
	if err != nil {
		log.Fatal(err)
	}

	version, err := exec.Command(File.Cmd, "version").Output()
	if err != nil {
		log.Fatal(err)
	}

	// Server

	file, err := os.OpenFile(FILE_SERVER_GO, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0666)
	if err != nil {
		log.Fatal(err)
	}

	tmpl := template.Must(template.New("").Parse(TMPL_SERVER_GO))
	data := struct {
		System     string
		Arch       string
		Version    string
		Date       string
		ValidUntil string
		CACert     string
		Cert       string
		Key        string
	}{
		runtime.GOOS,
		runtime.GOARCH,
		strings.TrimRight(string(version), "\n"),
		time.Now().Format(time.RFC822),
		fmt.Sprint(strings.TrimRight(InfoEndDate(certFile), "\n")),
		GoBlock(caCertBlock).String(),
		GoBlock(certBlock).String(),
		GoBlock(keyBlock).String(),
	}

	err = tmpl.Execute(file, data)
	file.Close()
	if err != nil {
		log.Fatal(err)
	}

	// Client

	file, err = os.OpenFile(FILE_CLIENT_GO, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0666)
	if err != nil {
		log.Fatal(err)
	}

	tmpl = template.Must(template.New("").Parse(TMPL_CLIENT_GO))

	err = tmpl.Execute(file, data)
	file.Close()
	if err != nil {
		log.Fatal(err)
	}
}

// == Template
//

const TMPL_SERVER_GO = `// MACHINE GENERATED BY easycert (github.com/kless/easycert)
// From {{.System}} ({{.Arch}}) with "{{.Version}}", on {{.Date}}
// Server valid for: {{.ValidUntil}}

package main

import (
	"crypto/tls"
	//"crypto/x509"
	"log"
)

var ServerTLSConfig *tls.Config

func init() {
	/*CA_CERT_BLOCK := {{.CACert}}*/

	CERT_BLOCK := {{.Cert}}

	KEY_BLOCK := {{.Key}}

	cert, err := tls.X509KeyPair(CERT_BLOCK, KEY_BLOCK)
	if err != nil {
		log.Fatal("server: load keys: ", err)
	}

	/*certPool := x509.NewCertPool()
	if ok := certPool.AppendCertsFromPEM(CA_CERT_BLOCK); !ok {
		log.Fatal("server: CertPool: CA certificate not valid")
	}*/

	ServerTLSConfig = &tls.Config{
		Certificates: []tls.Certificate{cert},
		//ClientCAs:    certPool,
	}
}
`

const TMPL_CLIENT_GO = `// MACHINE GENERATED BY easycert (github.com/kless/easycert)
// From {{.System}} ({{.Arch}}) with "{{.Version}}", on {{.Date}}
// Server valid for: {{.ValidUntil}}

// MUST set the filenames for both certificate and key
// var CertFile, KeyFile string

package main

import (
	"crypto/tls"
	"crypto/x509"
	"log"
)

var ClientTLSConfig *tls.Config

func init() {
	CA_CERT_BLOCK := {{.CACert}}

	cert, err := tls.LoadX509KeyPair(CertFile, KeyFile)
	if err != nil {
		log.Fatal("client: load keys: ", err)
	}

	certPool := x509.NewCertPool()
	if ok := certPool.AppendCertsFromPEM(CA_CERT_BLOCK); !ok {
		log.Fatal("client: CertPool: CA certificate not valid")
	}

	ClientTLSConfig = &tls.Config{
		Certificates: []tls.Certificate{cert},
		RootCAs:      certPool,
		//CipherSuites: []uint16{tls.}
	}
}
`

// GoBlock represents the definition of a "[]byte" in Go.
type GoBlock []byte

func (b GoBlock) String() string {
	s := make([]string, len(b))

	for i, v := range b {
		if i != 0 && i%18 == 0 {
			s[i-1] = s[i-1][:len(s[i-1])-1] // remove anterior space
			s[i] = "\n\t\t"
		}
		s[i] += fmt.Sprintf("%s, ", strconv.Itoa(int(v)))
	}

	i := len(s) - 1
	s[i] = s[i][:len(s[i])-1] // remove last space

	return fmt.Sprintf("[]byte{\n\t\t%s\n\t}", strings.Join(s, ""))
}
